===================================================================
D0019r5 : Atomic View
===================================================================

:Project: ISO JTC1/SC22/WG21: Programming Language C++
:Number: D0019r5
:Date: 2017-03-01
:Reply-to: hcedwar@sandia.gov
:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Hans Boehm
:Contact: hboehm@google.com
:Author: Olivier Giroux
:Contact: ogiroux@nvidia.com
:Author: James Reus
:Contact: reus1@llnl.gov
:Audience: Library Evolution
:URL: https://github.com/kokkos/ISO-CPP-Papers/blob/master/P0019.rst

******************************************************************
Revision History
******************************************************************

------------------------------------------------------------------------
P0019r3
------------------------------------------------------------------------

  - Align proposal with content of corresponding sections in N5131, 2016-07-15.

  - Remove the *one root wrapping constructor* requirement from **atomic_array_view**.

  - Other minor revisions responding to feedback from SG1 @ Oulu.

------------------------------------------------------------------------
P0019r4
------------------------------------------------------------------------

  - wrapper constructor strengthen requires clause and omit throws clause

  - Note types must be trivially copyable, as required for all atomics

  - 2016-11-09 Issaquah SG1 decision: move to LEWG targeting Concurrency TS V2

------------------------------------------------------------------------
D0019r5
------------------------------------------------------------------------

  - 2017-03-01 Kona LEWG review

    - Merge in P0440 Floating Point Atomic View because LEWG
      consensus to move P0020 Floating Point Atomic to C++20 IS

    - Rename from **atomic_view** and **atomic_array_view**
      to **atomic_ref<T>** and **atomic_ref<T[]>**,
      other name suggested **atomic_wrapper**.

    - Remove **constexpr** qualification from default constructor
      because this qualification constrains implementations and
      does not add apparent value.

  - Remove move copy constructor and move assignment operator.

******************************************************************
Overview / Motivation / Discussion
******************************************************************

This paper proposes an extension to the atomic operations library [atomics]
for atomic operations applied to non-atomic objects.
As required by [atomics.types.generic] 20.5p1 the wrapped type **T**
must be trivially copiable.
This paper includes *atomic floating point* extensions in P0020r5.

-----------------------------------------------------
Naming
-----------------------------------------------------

The current **29.2 Header <atomic> synopsis** contains the following.

  |  namespace std {
  |    template< class T > struct atomic;
  |    template<> struct atomic< *integral* >;
  |    template< class T > struct atomic<T\*>;
  |  }

The current proposal introduces the following additional types.

  |  namespace std {
  |  namespace experimental {
  |
  |    template< class T > struct atomic_ref;
  |    template<> struct atomic_ref< *integral* >;
  |    template<> struct atomic_ref< *floating-point* >;
  |    template< class T > struct atomic_ref<T\*>;
  |    template< class T > struct atomic_ref<T[]>;;
  |
  |  }}

Another possible name suggested by LEWG is **atomic_wrapper**. 

-----------------------------------------------------
Atomic Operations on a Single Non-atomic Object
-----------------------------------------------------

An *atomic reference* is used to perform
atomic operations on referenced non-atomic object.
The intent is for *atomic reference* to provide the best-performing
implementation of atomic operations for the non-atomic object type.
All atomic operations performed through an *atomic reference*
on a referenced non-atomic object
are atomic with respect to any other *atomic reference* that references
the same object, as defined by equality of pointers to that object. 
The intent is for atomic operations
to directly update the referenced object.
The *atomic reference wrapping constructor* may acquire a resource,
such as a lock from a collection of address-sharded locks,
to perform atomic operations.
Such *atomic reference* objects are not lock-free and not address-free.
When such a resource is necessary subsequent
copy and move constructors and assignment operators
may reduce overhead by copying or moving the previously
acquired resource as opposed to re-acquiring that resource.

Introducing concurrency within legacy codes may require
replacing operations on existing non-atomic objects with atomic operations
such that the non-atomic object cannot be replaced with a **atomic** object.

An object may be heavily used non-atomically in well-defined phases
of an application.  Forcing such objects to be exclusively **atomic**
would incur an unnecessary performance penalty.

---------------------------------------------------------------
Atomic Operations on Members of a Very Large Array
---------------------------------------------------------------

High performance computing (HPC) applications use very large arrays.
Computations with these arrays typically have distinct phases that
allocate and initialize members of the array,
update members of the array,
and read members of the array.
Parallel algorithms for initialization (e.g., zero fill)
have non-conflicting access when assigning member values.
Parallel algorithms for updates have conflicting access
to members which must be guarded by atomic operations.
Parallel algorithms with read-only access require best-performing
streaming read access, random read access, vectorization,
or other guaranteed non-conflicting HPC pattern.

An *atomic array reference* is used to perform
atomic operations on the non-atomic members of the referenced array.
The intent is for *atomic array reference* to provide the
best-performing implementation of atomic operations
for the members of the array.  

---------------------------------------------------------------
Wrapping Constructor Error Response
---------------------------------------------------------------

The *wrapping constructor* of an atomic reference is responsible
for detecting potential errors associated with wrapping
a non-atomic object.
For example, if the object does satisfy alignment requirements or
resides in memory where atomic operations are not supported
(e.g, GPU registers).
The wrapping constructor's response to such errors is
to throw an exception, an alternative response is to abort.


******************************************************************
Proposal
******************************************************************

-------------------------------------------
*add to* 29.2 Header <atomic> synopsis
-------------------------------------------

  |  namespace std {
  |  namespace experimental {
  |
  |    template< class T > struct atomic_ref ;
  |    template<> struct atomic_ref< *integral* >;
  |    template<> struct atomic_ref< *floating-point* >;
  |    template< class T > struct atomic_ref< T \* >;
  |    template< class T > struct atomic_ref< T[] >;
  |
  |  }}

-------------------------------------------
*add to* 29.5 Atomic Types
-------------------------------------------

  |  template< class T > struct atomic_ref {
  |    static constexpr size_t required_alignment = *implementation-defined* ;
  |    static constexpr bool is_always_lock_free = *implementation-defined* ;
  |    bool is_lock_free() const noexcept;
  |    void store( T , memory_order = memory_order_seq_cst ) const noexcept;
  |    T load( memory_order = memory_order_seq_cst ) const noexcept;
  |    operator T() const noexcept ;
  |    T exchange( T , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_weak( T& , T , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_strong( T& , T , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_weak( T& , T , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_strong( T&, T, memory_order = memory_order_seq_cst ) const noexcept;
  |
  |    ~atomic_ref();
  |    atomic_ref() noexcept ;
  |    atomic_ref( const atomic_ref & ) noexcept ;
  |    atomic_ref & operator = ( const atomic_ref & ) noexcept ;
  |    T operator=(T) const noexcept ;
  |    
  |    explicit atomic_ref( T & obj ); // *wrapping* constructor
  |    explicit constexpr operator bool () const noexcept; // *wraps*
  |  };
  |
  |  template<> struct atomic_ref< *integral* > {
  |    static constexpr size_t required_alignment = *implementation-defined* ;
  |    static constexpr bool is_always_lock_free = *implementation-defined* ;
  |    bool is_lock_free() const noexcept;
  |    void store( *integral* , memory_order = memory_order_seq_cst ) const noexcept;
  |    *integral* load( memory_order = memory_order_seq_cst ) const noexcept;
  |    operator *integral* () const noexcept ;
  |    *integral* exchange( *integral* , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_weak( *integral* & , *integral* , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_strong( *integral* & , *integral*  , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_weak( *integral* & , *integral*  , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_strong( *integral* &, *integral* , memory_order = memory_order_seq_cst ) const noexcept;
  |
  |    *integral* fetch_add( *integral* , memory_order = memory_order_seq_cst) const noexcept;
  |    *integral* fetch_sub( *integral* , memory_order = memory_order_seq_cst) const noexcept;
  |    *integral* fetch_and( *integral* , memory_order = memory_order_seq_cst) const noexcept;
  |    *integral* fetch_or(  *integral* , memory_order = memory_order_seq_cst) const noexcept;
  |    *integral* fetch_xor( *integral* , memory_order = memory_order_seq_cst) const noexcept;
  |
  |    ~atomic_ref();
  |    atomic_ref() noexcept ;
  |    atomic_ref( const atomic_ref & ) noexcept ;
  |    atomic_ref & operator = ( const atomic_ref & ) noexcept ;
  |    *integral* operator=( *integral* ) const noexcept ;
  |    
  |    explicit atomic_ref(  *integral*  & obj ); // *wrapping* constructor
  |    explicit constexpr operator bool () const noexcept; // *wraps*
  |
  |    *integral* operator++(int) const noexcept;
  |    *integral* operator--(int) const noexcept;
  |    *integral* operator++() const noexcept;
  |    *integral* operator--() const noexcept;
  |    *integral* operator+=( *integral* ) const noexcept;
  |    *integral* operator-=( *integral* ) const noexcept;
  |    *integral* operator&=( *integral* ) const noexcept;
  |    *integral* operator|=( *integral* ) const noexcept;
  |    *integral* operator^=( *integral* ) const noexcept;
  |  };
  |
  |  template<> struct atomic_view< *floating-point* > {
  |    static constexpr size_t required_alignment = *implementation-defined* ;
  |    static constexpr bool is_always_lock_free = *implementation-defined* ;
  |    bool is_lock_free() const noexcept;
  |    void store( *floating-point* , memory_order = memory_order_seq_cst ) const noexcept;
  |    *floating-point* load( memory_order = memory_order_seq_cst ) const noexcept;
  |    operator *floating-point* () const noexcept ;
  |    *floating-point* exchange( *floating-point* , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_weak( *floating-point* & , *floating-point* , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_strong( *floating-point* & , *floating-point*  , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_weak( *floating-point* & , *floating-point*  , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_strong( *floating-point* &, *floating-point* , memory_order = memory_order_seq_cst ) const noexcept;
  |
  |    *floating-point* fetch_add( *floating-point* , memory_order = memory_order_seq_cst) const noexcept;
  |    *floating-point* fetch_sub( *floating-point* , memory_order = memory_order_seq_cst) const noexcept;
  |
  |    atomic_view() noexcept ;
  |    atomic_view( const atomic_view & ) noexcept ;
  |    atomic_view & operator = ( const atomic_view & ) noexcept ;
  |    *floating-point* operator=( *floating-point* ) noexcept ;
  |
  |    explicit atomic_view( *floating-point* & obj ) noexcept ;
  |    explicit constexpr operator bool () const noexcept;
  |
  |    *floating-point* operator+=( *floating-point* ) const ;
  |    *floating-point* operator-=( *floating-point* ) const ;
  |  };
  |
  |  template<class T> struct atomic_ref< T * > {
  |    static constexpr size_t required_alignment = *implementation-defined* ;
  |    static constexpr bool is_always_lock_free = *implementation-defined* ;
  |    bool is_lock_free() const noexcept;
  |    void store( T * , memory_order = memory_order_seq_cst ) const noexcept;
  |    T * load( memory_order = memory_order_seq_cst ) const noexcept;
  |    operator T * () const noexcept ;
  |    T * exchange( T * , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_weak( T * & , T * , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_strong( T * & , T *  , memory_order , memory_order ) const noexcept;
  |    bool compare_exchange_weak( T * & , T *  , memory_order = memory_order_seq_cst ) const noexcept;
  |    bool compare_exchange_strong( T * &, T * , memory_order = memory_order_seq_cst ) const noexcept;
  |
  |    T * fetch_add( ptrdiff_t , memory_order = memory_order_seq_cst) const noexcept;
  |    T * fetch_sub( ptrdiff_t , memory_order = memory_order_seq_cst) const noexcept;
  |
  |    ~atomic_ref();
  |    atomic_ref() noexcept ;
  |    atomic_ref( const atomic_ref & ) noexcept ;
  |    atomic_ref & operator = ( const atomic_ref & ) noexcept ;
  |    T * operator=( T * ) const noexcept ;
  |    
  |    explicit atomic_ref( T * & obj ); // *wrapping* constructor
  |    explicit constexpr operator bool () const noexcept; // *wraps*
  |
  |    T * operator++(int) const noexcept;
  |    T * operator--(int) const noexcept;
  |    T * operator++() const noexcept;
  |    T * operator--() const noexcept;
  |    T * operator+=( ptrdiff_t ) const noexcept;
  |    T * operator-=( ptrdiff_t ) const noexcept;
  |  };
  |
  |  template< class T > struct atomic_ref< T[] > {
  |
  |    static constexpr size_t required_alignment = *implementation defined* ;
  |    static constexpr bool is_always_lock_free = *implementation defined* ;
  |    bool is_lock_free() const noexcept ;
  |
  |    explicit constexpr operator bool() const noexcept ;
  |
  |    atomic_array_ref( T * , size_t ); // wrapping constructor
  |
  |    atomic_ref() noexcept ;
  |    atomic_ref( const atomic_ref & ) noexcept ;
  |    atomic_ref & operator = ( const atomic_ref & ) noexcept ;
  |    ~atomic_ref();
  |
  |    size_t size() const noexcept ;
  |
  |    atomic_ref<T> operator[]( size_t ) const noexcept;
  |  };

1  There are generic class templates atomic<T> and atomic_ref<T>.

-------------------------------------------------------------------------
*add* 29.6.6 Requirements for operations on atomic reference types
-------------------------------------------------------------------------

In the following operation definitions:

  - an *A* refers to one of the atomic reference types.

  - a *C* refers to its corresponding non-atomic type

  - an *M* refers to type of other argument for arithmetic operations.
    For integral atomic reference types, *M* is *C*.
    For atomic reference address types, *M* is **std::ptrdiff_t**.


**static constexpr bool A::is_always_lock_free =** *implementation-defined* **;**

  Is true if the atomic operations are always lock-free, and false otherwise.


**bool A::is_lock_free() const noexcept;**

  Returns: **true** if the atomic operations are lock-free, **false** otherwise.


**static constexpr size_t required_alignment =** *implementation-defined* **;**

  The required alignment of an object to be referenced by an atomic reference,
  which is at least ``align_of(C)``.
  [Note: An architecture may support lock-free atomic operations
  on objects of type *C* only if those objects meet a required
  alignment.  The intent is for *atomic_ref* to provide lock-free
  atomic operations whenever possible. 
  For example, an architecture may be able to support lock-free
  operations on **std::complex<double>** only if aligned to 16 bytes
  and not 8 bytes. - end note]


**A::A() noexcept;**

  Effects: **\*this** does not reference an object.


**A::A( C & object );**

  This *wrapping constructor* constructs an *atomic reference*
  that references the non-atomic *object*.
  Atomic operations applied to *object* through a referencing
  *atomic reference* are atomic with respect to atomic operations
  applied through any other *atomic reference* that references that *object*.

  Requires: The referenced non-atomic *object* shall be
  aligned to **required_alignment**.
  The lifetime (3.8) of **\*this**
  shall not exceed the lifetime of the referenced non-atomic object.
  While any **atomic_ref** instance exists that references *object*
  all accesses of that *object* shall exclusively occur through those
  **atomic_ref** instances.
  If the referenced *object* is of a class or aggregate type
  then members of that object shall not be concurrently
  wrapped by an **atomic_ref** object.
  The referenced *object* shall not be a member of an array that
  is wrapped by an **atomic_ref<T[]>** .
  [Note: Other implementation dependent conditions may exist.
  For example, successful acquisition of a lock associated with
  the referenced *object* ,
  or the referenced object cannot have automatic storage duration
  within a GPGPU execution context. - end note]

  Effects: **\*this** references the non-atomic *object*.
  [Note: The *wrapping constructor* may acquire a shared resource,
  such as a lock associated with the referenced object,
  to enable atomic operations applied to the referenced
  non-atomic object. - end note]


| **A::A( A const & rhs ) noexcept ;**
| **A & A::operator = ( A const & rhs ) noexcept ;**

  Effects: If *rhs* references an object
  then **\*this** references the same object,
  otherwise **\*this** does not reference an object.
  If *rhs* also references a shared resource
  then **\*this** references that shared resource,
  otherwise **\*this** does not reference a shared resource.

**A::~A() noexcept ;**

  Effects: [Note: If **\*this** references an acquired shared resource
  then **\*this** releases that shared resource. - end note]

**explicit constexpr A::operator bool () const noexept ;**

  Returns: **true** if **\*this** references a non-atomic object,
  otherwise **false**.


**void A::atomic_store( C::desired, memory_order order = memory_order_seq_cst ) const noexcept;**

  Requires: **\*this** references an object.
  The order argument shall not be memory_order_consume,
  memory_order_acquire, nor memory_order_acq_rel.

  Effects: Atomically replaces the value referenced by **\*this**
  with the value of *desired*.
  Memory is affected according to the value of order.

**C A::operator=( C desired ) const noexcept;**

  Effects: As if by **A::store(desired)**.

  Returns: *desired*.


**void A::atomic_load( memory_order order = memory_order_seq_cst ) const noexcept;**

  Requires: **\*this** references an object.
  The order argument shall not be memory_order_release
  nor memory_order_acq_rel.

  Effects: Memory is affected according to the value of order.

  Returns: Atomically returns the value referenced by **\*this** .


**A::operator C() const noexcept;**

  Effects:  As if by **A::load()**.


**C A::exchange(C desired, memory_order order = memory_order_seq_cst) noexcept;**

  Requires: **\*this** references an object.

  Effects: Atomically replaces the value referenced by **\*this**
  with *desired*. Memory is affected according to the value of *order*.
  These operations are atomic read-modify-write operations (1.10).

  Returns: Atomically returns the value referenced by **\*this**
  immediately before the effects.


| **bool A::compare_exchange_weak(C & expected, C desired, memory_order success, memory_order failure) const noexcept;**
| **bool A::compare_exchange_strong(C & expected, C desired, memory_order success, memory_order failure) const noexcept;**
| **bool A::compare_exchange_weak(C & expected, C desired,memory_order order = memory_order_seq_cst) const noexcept;**
| **bool A::compare_exchange_strong(C & expected, C desired, memory_order order = memory_order_seq_cst) const noexcept;**

  Requires: **\*this** references an object.
  The *failure* argument shall not be
  memory_order_release nor memory_order_acq_rel.
  The *failure* argument shall be no stronger than the *success* argument.

  Effects: Retrieves the value in *expected*.
  It then atomically compares the contents of the memory referenced
  by **\*this** for equality with that previously retrieved from
  *expected*, and if true, replaces the contents of the memory
  referenced by **\*this** with that in *desired*.
  If and only if the comparison is true, memory is affected
  according to the value of success, and if the comparison is false,
  memory is affected according to the value of failure.
  When only one memory_order argument is supplied,
  the value of success is *order*, and the value of failure is *order*
  except that a value of memory_order_acq_rel shall be replaced by
  the value memory_order_acquire and a value of
  memory_order_release shall be replaced by the value memory_order_relaxed.
  If and only if the comparison is false then, after the atomic operation,
  the contents of the memory in *expected* are replaced by the value read
  from memory referenced by **\*this** during the atomic comparison.
  If the operation returns true, these operations are atomic
  read-modify-write operations (1.10) on the memory referenced
  by **\*this**.  Otherwise, these operations are atomic load operations
  on that memory.

  Returns: The result of the comparison.

  [Note: See 29.6.5 p24-27 notes and remarks. --end node]


**A::fetch_**\ *key*\ **(M operand, memory_order order = memory_order_seq_cst) const noexcept;**

  Requires: **\*this** references an object.

  Effects: Atomically replaces the value referenced by **\*this**
  with the result of the computation applied to the value
  referenced by **\*this** and the given operand.
  Memory is affected according to the value of *order*.
  These operations are atomic read-modify-write operations (1.10).

  Returns: Atomically, the value referenced by **\*this**
  immediately before the effects.

  *Remark:* For signed integer types, arithmetic is defined to use
  twoâ€™s complement representation and there are no undefined results.
  For floating-point types, if the result is not mathematically defined or
  not in the range of representable values for its type (5p4)
  the result is unspecified, but the operations
  otherwise have no undefined behavior.
  [Note:  Atomic arithmetic operations on *floating-point*
  should conform to **std::numeric_limits<** *floating-point* **>**
  traits associated with the floating-point type (18.3.2).
  The floating-point environment (26.4) for atomic arithmetic operations
  on *floating-point* may be different than the calling thread's
  floating-point environment.  - end note]
  For address types, the result may be an undefined address, but the operations
  otherwise have no undefined behavior.


**A::operator** *op* **=(M operand) const noexcept;**

  Effects: As if by fetch_key (operand).

  Returns: fetch_key (operand) op operand.

**A::operator++(int) const noexcept;**

  Returns: fetch_add(1).

**A::operator--(int) const noexcept;**

  Returns: fetch_sub(1).

**A::operator++() const noexcept;**

  Effects: As if by fetch_add(1).

  Returns: fetch_add(1) + 1.

**C::operator--() const noexcept;**

  Effects: As if by fetch_sub(1).

  Returns: fetch_sub(1) - 1.


-------------------------------------------------------------------------
*add* 29.6.7 Requirements for operations on atomic array reference types
-------------------------------------------------------------------------

In the following operation definitions:

  - an *A* refers to one of the atomic array reference types.

  - a *C* refers to its corresponding non-atomic type


**static constexpr bool A::is_always_lock_free =** *implementation-defined* **;**

  Is true if the atomic operations are always lock-free, and false otherwise.


**bool A::is_lock_free() const noexcept;**

  Returns: **true** if atomic operations are lock-free, **false** otherwise.


**static constexpr size_t required_alignment =** *implementation-defined* **;**

  The required alignment of an array to be referenced by an atomic reference,
  which is at least ``align_of(C)``.

  Remark: An architecture may support lock-free atomic operations
  on objects of type *C* only if those objects meet a required
  alignment.  The intent is for *atomic_ref<T[]>* to provide lock-free
  atomic operations whenever possible. 
  [Note: For example, an architecture may be able to support lock-free
  operations on **std::complex<double>** only if aligned to 16 bytes
  and not 8 bytes. - end note]


**A::A() noexcept;**

  Effects: **\*this** does not reference an array and
  therefore **operator bool() == false**.

**A::A( C * array , size_t length );**

  This *wrapping constructor* constructs an *atomic_ref<T[]>*
  that references an array of non-atomic elements
  spanning ``[array..array+length)``.

  Requires: The referenced non-atomic array shall be
  aligned to **required_alignment**.
  The lifetime (3.8) of **\*this**
  shall not exceed the lifetime of the referenced non-atomic array.
  All **atomic_ref<T[]>** instances that reference any element of
  the array shall reference the same span of the array.
  As long as any **atomic_ref<T[]>** instance exists that references
  array all accesses to members of that array shall exclusively occur
  through those **atomic_ref<T[]>** instances.
  No element of array is concurrently *wrap constructed* by an
  **atomic_ref<T>**.
  [Note: Other implementation dependent conditions may exist.
  For example, successful acquisition of a locks associated with
  the referenced *array* ,
  or the referenced array cannot have automatic storage duration
  within a GPGPU execution context. - end note]

  Effects: **\*this** references the non-atomic array.
  Atomic operations on members of array are atomic with respect
  to atomic operations on members referenced through any other
  **atomic_ref<T[]>** instance.
  [Note: The *wrapping constructor* may acquire shared resources,
  such as a locks associated with the referenced array,
  to enable atomic operations applied to the referenced
  non-atomic members of referenced array. - end note]


| **A::A( A const & rhs ) noexcept ;**
| **A & A::operator = ( A const & rhs ) noexcept ;**

  Effects: If *rhs* references an array
  then **\*this** references the same array,
  otherwise **\*this** does not reference an array.
  If *rhs* also references shared resources
  then **\*this** references those shared resources,
  otherwise **\*this** does not reference shared resources.

**A::~A() noexcept ;**

  Effects: [Note: If **\*this** references acquired shared resources
  then **\*this** releases those shared resources. - end note]

**explicit constexpr A::operator bool () const noexept ;**

  Returns: **true** if **\*this** references a non-atomic array,
  otherwise **false**.


**atomic_view<C> A::operator[]( size_t i ) const noexcept ;**

  Requires: **i < size()** and the lifetime of the returned
  **atomic_ref**\ shall not exceed the lifetime of the
  associated **atomic_ref<T[]>**.
  [Note: Analogous to the lifetime of an iterator with respect to the
  lifetime of the associated container. - end note]

  Example usage:

.. code-block:: c++

  // atomic reference wrapper constructor:
  atomic_ref<T[]> array( ptr , N );

  // atomic operation on a member:
  array[i].atomic-operation(...);

  // atomic operations through a temporary value 
  // within a concurrent function:
  auto x = array[i];
  x.atomic-operation-a(...);
  x.atomic-operation-b(...);

..

